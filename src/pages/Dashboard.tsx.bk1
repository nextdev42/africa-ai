import { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import { supabase } from "@/integrations/supabase/client";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { GraduationCap, Trophy, Flame, BookOpen, LogOut, Award, CheckCircle, X, Eye, Lock } from "lucide-react";
import { toast } from "sonner";
import ReactMarkdown from 'react-markdown';

type QuizQuestion = {
  id: string;
  question: string;
  options: string[];
  correct_answer: string;
};

type Module = {
  id: string;
  user_id: string;
  module_id: string;
  title: string;
  description: string;
  difficulty: string;
  estimated_duration: number;
  points_reward: number;
  progress_percentage: number;
  is_completed: boolean;
  detailed_content: string | null;
  interest?: string;
  quizzes?: QuizQuestion[];
};

const Dashboard = () => {
  const navigate = useNavigate();
  const [profile, setProfile] = useState<any>(null);
  const [modules, setModules] = useState<Module[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedModule, setSelectedModule] = useState<Module | null>(null);
  const [answers, setAnswers] = useState<Record<string, string>>({});
  const [quizResults, setQuizResults] = useState<Record<string, boolean>>({});
  const [completedQuizzes, setCompletedQuizzes] = useState<Set<string>>(new Set());
  const [moduleLoading, setModuleLoading] = useState<string | null>(null);
  const [completingModule, setCompletingModule] = useState<boolean>(false);
  const [generatingModules, setGeneratingModules] = useState<boolean>(false);
  const [generatingQuizzes, setGeneratingQuizzes] = useState<boolean>(false);

  // Calculate points based on duration and difficulty
  const calculatePointsReward = (duration: number, difficulty: string): number => {
    const basePoints = Math.round(duration / 10);
    const difficultyMultiplier = {
      beginner: 1,
      intermediate: 1.5,
      advanced: 2
    };
    const multiplier = difficultyMultiplier[difficulty as keyof typeof difficultyMultiplier] || 1;
    const calculatedPoints = Math.round(basePoints * multiplier);
    return Math.max(5, Math.round(calculatedPoints / 5) * 5);
  };

  useEffect(() => {
    console.log("üîç Dashboard component mounted");
    const init = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session?.user) {
        console.log("‚ùå No session found, redirecting to auth");
        navigate("/auth");
        return;
      }
      console.log("‚úÖ Session found, loading data for user:", session.user.id);
      await loadData(session.user.id);
    };
    init();
  }, []);

  const loadData = async (userId: string) => {
    console.log("üì• loadData called for user:", userId);
    try {
      const { data: profileData, error: profileError } = await supabase
        .from("profiles")
        .select("*")
        .eq("id", userId)
        .single();
      
      if (profileError) {
        console.error("‚ùå Profile error:", profileError);
        throw profileError;
      }
      
      console.log("‚úÖ Profile loaded:", profileData);
      setProfile(profileData);
      await loadModulesFromDatabase(userId);
      setLoading(false);
      console.log("‚úÖ Loading complete");
    } catch (err) {
      console.error("‚ùå Load data error:", err);
      toast.error("Failed to load data");
      setLoading(false);
    }
  };

  const loadModulesFromDatabase = async (userId: string) => {
    console.log("üì• Loading modules from database for user:", userId);
    
    const { data: modulesData, error: modulesError } = await supabase
      .from("user_module_progress")
      .select("*")
      .eq("user_id", userId)
      .order('created_at', { ascending: false });

    console.log("üì¶ Database query results:");
    console.log("   - modulesData:", modulesData);
    console.log("   - modulesError:", modulesError);

    if (modulesError) {
      console.error("‚ùå Modules error:", modulesError);
      return;
    }

    if (!modulesData || modulesData.length === 0) {
      console.log("‚ÑπÔ∏è No modules found in database");
      return;
    }

    console.log("‚úÖ Found modules:", modulesData.length);
    modulesData.forEach((module, index) => {
      console.log(`   Module ${index + 1}:`, {
        id: module.id,
        module_id: module.module_id,
        title: module.title,
        is_completed: module.is_completed,
        progress_percentage: module.progress_percentage
      });
    });

    // Remove duplicates by keeping only the most recent record per module_id
    const uniqueModules = modulesData.reduce((acc: Module[], current) => {
      const existingIndex = acc.findIndex(module => module.module_id === current.module_id);
      
      if (existingIndex === -1) {
        // New module_id, add to accumulator
        acc.push(current);
      } else {
        // Duplicate module_id found, keep the one with highest priority:
        // 1. Completed modules first
        // 2. Higher progress percentage
        // 3. More recent (based on already sorted by created_at DESC)
        const existing = acc[existingIndex];
        if (current.is_completed && !existing.is_completed) {
          acc[existingIndex] = current;
        } else if (current.progress_percentage > existing.progress_percentage) {
          acc[existingIndex] = current;
        }
        // Otherwise keep the existing one (more recent)
      }
      return acc;
    }, []);

    console.log("‚úÖ Unique modules after deduplication:", uniqueModules.length);
    uniqueModules.forEach((module, index) => {
      console.log(`   Unique Module ${index + 1}:`, {
        id: module.id,
        module_id: module.module_id,
        title: module.title,
        is_completed: module.is_completed,
        progress_percentage: module.progress_percentage
      });
    });

    const modulesWithConsistentPoints = uniqueModules.map(module => ({
      ...module,
      points_reward: module.points_reward > 0 ? module.points_reward : calculatePointsReward(module.estimated_duration, module.difficulty)
    }));

    setModules(modulesWithConsistentPoints);
    console.log("‚úÖ Modules set in state with consistent points");
  };

  const generateNewModules = async (userId: string) => {
    console.log("üöÄ Generating new modules for user:", userId);
    setGeneratingModules(true);
    try {
      const response = await fetch("/api/generateModules", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ userId }),
      });
      
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      
      const result = await response.json();
      console.log("üéØ API Response - Generated modules:", result.modules);

      if (result.modules && result.modules.length > 0) {
        const modulesWithConsistentState = result.modules.map((module: Module) => {
          const consistentPoints = calculatePointsReward(module.estimated_duration, module.difficulty);
          return {
            ...module,
            progress_percentage: 0,
            is_completed: false,
            points_reward: consistentPoints
          };
        });
        
        // Save to database - now protected by unique constraint
        const modulesToInsert = modulesWithConsistentState.map(module => ({
          user_id: userId,
          module_id: module.id,
          title: module.title,
          description: module.description,
          difficulty: module.difficulty,
          estimated_duration: module.estimated_duration,
          points_reward: module.points_reward,
          progress_percentage: 0,
          is_completed: false,
          detailed_content: module.detailed_content
        }));

        console.log("üíæ Saving modules to database:", modulesToInsert);
        const { error } = await supabase
          .from("user_module_progress")
          .insert(modulesToInsert);

        if (error) {
          console.error("‚ùå Database insert error:", error);
          // If it's a unique constraint violation, just load existing data
          if (error.code === '23505') {
            console.log("‚ÑπÔ∏è Unique constraint violation, loading existing modules");
            await loadModulesFromDatabase(userId);
            toast.info("Modules already exist, loading current progress");
            return;
          }
          throw error;
        }

        setModules(modulesWithConsistentState);
        console.log("‚úÖ Modules generated and saved successfully");
        toast.success("Learning modules generated successfully!");
      }
    } catch (err: any) {
      console.error("‚ùå Error generating modules:", err);
      toast.error(`Failed to generate learning modules: ${err.message}`);
    } finally {
      setGeneratingModules(false);
    }
  };

  const generateQuizzesForModule = async (module: Module): Promise<QuizQuestion[]> => {
    console.log("üéØ Generating quizzes for module:", module.title);
    setGeneratingQuizzes(true);
    try {
      const response = await fetch("/api/generateQuizzes", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          moduleTitle: module.title,
          moduleContent: module.detailed_content || module.description,
          difficulty: module.difficulty
        }),
      });
      
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      
      const result = await response.json();
      console.log("‚úÖ API Response - Generated quizzes:", result.quizzes);

      if (result.quizzes && result.quizzes.length > 0) {
        return result.quizzes;
      } else {
        throw new Error("No quizzes returned from API");
      }
    } catch (err: any) {
      console.error("‚ùå Error generating quizzes:", err);
      toast.error("Failed to generate quizzes. Please try again.");
      throw err;
    } finally {
      setGeneratingQuizzes(false);
    }
  };

  const openModule = async (module: Module) => {
    console.log("üö™ OPENING MODULE - Full module data:", module);
    console.log("   - Module ID:", module.id);
    console.log("   - Module module_id:", module.module_id);
    console.log("   - Is completed:", module.is_completed);
    console.log("   - Progress:", module.progress_percentage + "%");
    
    setModuleLoading(module.id);
    setSelectedModule(module);
    
    // Reset quiz state only for incomplete modules
    if (!module.is_completed) {
      console.log("üîÑ Resetting quiz state for incomplete module");
      setAnswers({});
      setQuizResults({});
      setCompletedQuizzes(new Set());
    } else {
      console.log("‚ÑπÔ∏è Module is completed, keeping existing quiz state");
      // For completed modules, ensure we don't allow new answers
      setAnswers({});
      setQuizResults({});
      setCompletedQuizzes(new Set());
    }

    // Generate quizzes only for incomplete modules without quizzes
    if ((!module.quizzes || module.quizzes.length === 0) && !module.is_completed) {
      console.log("üéØ Generating quizzes for incomplete module without quizzes");
      try {
        const quizzes = await generateQuizzesForModule(module);
        console.log("‚úÖ Generated quizzes:", quizzes.length);
        setSelectedModule(prev => prev ? { ...prev, quizzes } : null);
        setModules(prev => 
          prev.map(m => m.id === module.id ? { ...m, quizzes } : m)
        );
      } catch (err) {
        console.error("‚ùå Failed to generate quizzes:", err);
      }
    } else if (module.is_completed) {
      console.log("‚ÑπÔ∏è Module completed, skipping quiz generation");
    } else {
      console.log("‚ÑπÔ∏è Module already has quizzes:", module.quizzes?.length);
    }
    
    setModuleLoading(null);
    console.log("‚úÖ Module opening complete");
  };

  const closeModule = () => {
    console.log("üö™ Closing module dialog");
    setSelectedModule(null);
    setModuleLoading(null);
    setCompletingModule(false);
  };

  const markModuleComplete = async () => {
    console.log("üöÄ START markModuleComplete function");
    console.log("üìã Initial check - selectedModule:", selectedModule);
    console.log("üìã Initial check - profile:", profile);
    
    if (!selectedModule || !profile || selectedModule.is_completed) {
      console.log("‚ùå Early exit - missing data or already completed");
      console.log("   - selectedModule exists:", !!selectedModule);
      console.log("   - profile exists:", !!profile);
      console.log("   - selectedModule.is_completed:", selectedModule?.is_completed);
      toast.error("Module already completed or invalid");
      return;
    }

    setCompletingModule(true);
    console.log("üîÑ Setting completingModule to true");

    try {
      console.log("üìù Starting database update...");
      console.log("   - module_id to update:", selectedModule.module_id);
      console.log("   - user_id to update:", profile.id);
      
      // Use module_id instead of id for the update to ensure we're updating the correct record
      const { data, error } = await supabase
        .from("user_module_progress")
        .update({ 
          progress_percentage: 100, 
          is_completed: true 
        })
        .eq("module_id", selectedModule.module_id)
        .eq("user_id", profile.id)
        .select();

      console.log("‚úÖ Database update completed");
      console.log("   - Update result data:", data);
      console.log("   - Update error:", error);
      
      if (error) {
        console.log("‚ùå Database update failed with error:", error);
        throw error;
      }

      console.log("üí∞ Starting points award...");
      const newPoints = (profile.total_points || 0) + selectedModule.points_reward;
      console.log("   - Current points:", profile.total_points);
      console.log("   - Points to add:", selectedModule.points_reward);
      console.log("   - New points total:", newPoints);
      
      const { error: profileError } = await supabase
        .from("profiles")
        .update({ total_points: newPoints })
        .eq("id", profile.id);

      console.log("‚úÖ Points update completed");
      console.log("   - Profile update error:", profileError);
      
      if (!profileError) {
        setProfile((prev: any) => ({ ...prev, total_points: newPoints }));
        console.log("‚úÖ Local profile state updated with new points");
      }

      console.log("üîÑ Updating local modules state...");
      console.log("   - Current modules count:", modules.length);
      
      setModules(prev => {
        const updatedModules = prev.map(m =>
          m.module_id === selectedModule.module_id 
            ? { ...m, progress_percentage: 100, is_completed: true } 
            : m
        );
        console.log("   - Updated modules:", updatedModules);
        return updatedModules;
      });
      
      console.log("üîÑ Updating selected module state...");
      setSelectedModule(prev => {
        const updatedModule = prev ? { ...prev, progress_percentage: 100, is_completed: true } : null;
        console.log("   - Updated selected module:", updatedModule);
        return updatedModule;
      });
      
      console.log("üéâ Module completion successful!");
      toast.success(`Module completed! üéâ +${selectedModule.points_reward} points earned!`);
      
    } catch (err: any) {
      console.error("üí• Error completing module:", err);
      console.log("   - Error details:", err.message);
      console.log("   - Error stack:", err.stack);
      toast.error(`Failed to complete module: ${err.message}`);
    } finally {
      console.log("üèÅ Setting completingModule to false");
      setCompletingModule(false);
    }
  };

  const handleAnswerSelect = (quizId: string, answer: string) => {
    console.log("üéØ Answer selected for quiz:", quizId, "answer:", answer);
    if (selectedModule?.is_completed) {
      console.log("‚ùå Cannot change answers - module is completed");
      toast.info("This module is completed. You cannot change answers.");
      return;
    }
    setAnswers(prev => ({ ...prev, [quizId]: answer }));
  };

  const submitQuizAnswer = async (quiz: QuizQuestion) => {
    console.log("üì§ Submitting quiz answer:", quiz.id);
    if (!selectedModule || selectedModule.is_completed) {
      console.log("‚ùå Cannot submit - module is completed");
      toast.info("This module is completed. You cannot submit answers.");
      return;
    }

    const userAnswer = answers[quiz.id];
    if (!userAnswer) {
      console.log("‚ùå No answer selected");
      toast.error("Please select an answer");
      return;
    }

    const isCorrect = userAnswer === quiz.correct_answer;
    console.log("üìä Answer result - correct:", isCorrect);
    setQuizResults(prev => ({ ...prev, [quiz.id]: isCorrect }));
    setCompletedQuizzes(prev => new Set(prev).add(quiz.id));

    if (isCorrect) {
      toast.success("‚úÖ Correct answer!");
      
      // Award points
      const quizPoints = 5;
      const newPoints = (profile?.total_points || 0) + quizPoints;
      const { error: profileError } = await supabase
        .from("profiles")
        .update({ total_points: newPoints })
        .eq("id", profile.id);

      if (!profileError) {
        setProfile((prev: any) => ({ ...prev, total_points: newPoints }));
      }

      // Update progress
      const moduleQuizzes = selectedModule.quizzes || [];
      const completedCount = completedQuizzes.size + 1;
      const progressPercentage = Math.min(
        Math.floor((completedCount / moduleQuizzes.length) * 100),
        100
      );

      console.log("üìà Updating progress:", progressPercentage + "%");
      const { error } = await supabase
        .from("user_module_progress")
        .update({ progress_percentage: progressPercentage })
        .eq("module_id", selectedModule.module_id)
        .eq("user_id", profile.id);

      if (!error) {
        setModules(prev =>
          prev.map(m =>
            m.module_id === selectedModule.module_id 
              ? { ...m, progress_percentage: progressPercentage } 
              : m
          )
        );
        setSelectedModule(prev => 
          prev ? { ...prev, progress_percentage: progressPercentage } : null
        );
      }
    } else {
      toast.error("‚ùå Incorrect answer. Try again!");
    }
  };

  // Helper functions
  const calculateDayStreak = () => profile?.streak_days || 0;

  const getProgressColor = (percentage: number) => {
    if (percentage === 100) return "bg-green-500";
    if (percentage < 33) return "bg-red-500";
    if (percentage < 66) return "bg-yellow-500";
    return "bg-green-500";
  };

  const getReadOnlyOptionColor = (option: string, quiz: QuizQuestion, userAnswer: string | undefined) => {
    if (option === quiz.correct_answer) return 'bg-green-50 border-green-200 text-green-800';
    if (userAnswer && option === userAnswer && option !== quiz.correct_answer) return 'bg-red-50 border-red-200 text-red-800';
    return 'bg-gray-50 border-gray-200 text-gray-600';
  };

  if (loading) return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="animate-pulse text-2xl text-primary">Loading...</div>
    </div>
  );

  return (
    <div className="min-h-screen bg-gradient-to-br from-primary/5 via-background to-secondary/5">
      {/* Header and main content remain the same as your previous version */}
      {/* ... (rest of your JSX remains unchanged) ... */}
    </div>
  );
};

export default Dashboard;